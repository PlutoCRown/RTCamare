<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>WebRTC 单向视频传输</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji",
          "Segoe UI Emoji", sans-serif;
        margin: 24px;
      }
      video {
        width: 100%;
        max-width: 72px;
        background: #000;
        border-radius: 8px;
      }
      .row {
        display: flex;
        gap: 16px;
        flex-wrap: wrap;
        align-items: flex-start;
      }
      .col {
        flex: 1 1 320px;
      }
      code {
        background: #f5f5f5;
        padding: 2px 6px;
        border-radius: 4px;
      }
    </style>
  </head>
  <body>
    <div class="row">
      <div class="col">
        <h3>Local</h3>
        <video id="localVideo" autoplay playsinline muted></video>
      </div>
      <div class="col">
        <h3>Remote</h3>
        <video id="remoteVideo" autoplay playsinline></video>
      </div>
    </div>

    <script>
      const params = new URLSearchParams(location.search);
      const role = params.get("role") || "sender";
      const room = params.get("room") || "demo";

      const httpProto = location.protocol === "https:" ? "wss" : "ws";
      const ws = new WebSocket(`${httpProto}://${location.host}/ws`);

      let pc;
      let localStream;

      const localVideo = document.getElementById("localVideo");
      const remoteVideo = document.getElementById("remoteVideo");

      // 添加视频事件监听器
      remoteVideo.addEventListener("loadedmetadata", () => {
        log("Remote video loadedmetadata", {
          videoWidth: remoteVideo.videoWidth,
          videoHeight: remoteVideo.videoHeight,
          duration: remoteVideo.duration,
        });
      });

      remoteVideo.addEventListener("canplay", () => {
        log("Remote video canplay");
      });

      remoteVideo.addEventListener("play", () => {
        log("Remote video play event");
      });

      remoteVideo.addEventListener("error", (e) => {
        log("Remote video error", e);
      });

      function log(...args) {
        console.log("[webrtc]", ...args);
      }

      function createPeerConnection() {
        const config = {
          iceServers: [
            // 指向本服务自带的 STUN（请确保对端能访问到你的公网地址）
            { urls: `stun:${location.hostname}:3478` },
          ],
        };
        const _pc = new RTCPeerConnection(config);

        _pc.onicecandidate = (e) => {
          if (e.candidate) {
            ws.send(
              JSON.stringify({ type: "ice-candidate", candidate: e.candidate })
            );
          }
        };
        _pc.ontrack = (e) => {
          log("ontrack event received", e);
          if (!remoteVideo.srcObject) {
            remoteVideo.srcObject = e.streams[0];
            log("remote video srcObject set", e.streams[0]);

            // 确保视频元素属性正确
            remoteVideo.muted = false; // 确保不是静音状态
            remoteVideo.autoplay = true;
            remoteVideo.playsInline = true;

            // 尝试手动播放
            remoteVideo
              .play()
              .then(() => {
                log("Remote video play() succeeded");
              })
              .catch((err) => {
                log("Remote video play() failed", err);
              });

            // 检查视频元素状态
            setTimeout(() => {
              log("Video element state:", {
                srcObject: remoteVideo.srcObject,
                videoWidth: remoteVideo.videoWidth,
                videoHeight: remoteVideo.videoHeight,
                readyState: remoteVideo.readyState,
                paused: remoteVideo.paused,
                muted: remoteVideo.muted,
                autoplay: remoteVideo.autoplay,
              });
            }, 1000);
          }
        };

        _pc.oniceconnectionstatechange = () => {
          log("ICE connection state:", _pc.iceConnectionState);
        };

        _pc.onconnectionstatechange = () => {
          log("Connection state:", _pc.connectionState);
        };

        return _pc;
      }

      async function startSender() {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: false,
        });
        localVideo.srcObject = localStream;
        pc = await createPeerConnection();
        localStream.getTracks().forEach((t) => {
          log("adding track to sender", t);
          pc.addTrack(t, localStream);
        });
      }

      async function startViewer() {
        pc = await createPeerConnection();
        log("viewer peer connection created");
      }

      async function makeAndSendOffer() {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: "offer", sdp: offer }));
      }

      ws.addEventListener("open", async () => {
        ws.send(JSON.stringify({ type: "join", role, room }));
        if (role === "sender") {
          await startSender();
        } else {
          await startViewer();
          ws.send(JSON.stringify({ type: "ready" })); // 提示服务器通知 sender
        }
      });

      ws.addEventListener("message", async (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.type === "viewer-ready" && role === "sender") {
          await makeAndSendOffer();
        }
        if (msg.type === "offer" && role === "viewer") {
          log("received offer, setting remote description");
          await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          log("sending answer");
          ws.send(JSON.stringify({ type: "answer", sdp: answer }));
        }
        if (msg.type === "answer" && role === "sender") {
          log("received answer, setting remote description");
          await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
        }
        if (msg.type === "ice-candidate") {
          try {
            await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
          } catch (e) {
            log("addIceCandidate error", e);
          }
        }
        if (msg.type === "sender-left" && role === "viewer") {
          log("sender left");
        }
        if (msg.type === "viewer-left" && role === "sender") {
          log("viewer left");
        }
        if (msg.type === "error") {
          log("error", msg.reason);
        }
      });
    </script>
  </body>
</html>
